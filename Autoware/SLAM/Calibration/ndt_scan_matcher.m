%==========================================================================
% Function: Perform NDT scan matching
% Modified & Coded by: Surachet Srinara, PhD candidate
% Date: April 21, 2021 - 01:00AM
% Copyright@Chet2021
%==========================================================================
function [tform, movingReg, solutionInfo] = ndt_scan_matcher(moving, fixed, gridStep, varargin)
%PCREGISTERNDT Register two point clouds using NDT algorithm.
%   tform = PCREGISTERNDT(moving, fixed, gridStep) returns the rigid
%   transformation that registers the moving point cloud with the fixed
%   point cloud. moving and fixed are pointCloud objects. gridStep is a
%   positive scalar specifying the size of 3-D box that voxelizes the fixed
%   point cloud. tform is a rigid3d object that describes the rigid 3-D
%   transform. The rigid transformation between the moving and fixed point
%   clouds are estimated by the Normal-Distributions Transform (NDT)
%   algorithm.
%
%   [tform, movingReg] = PCREGISTERNDT(...) additionally returns the
%   transformed point cloud, movingReg, that is aligned with the fixed
%   point cloud.
%
%   [..., rmse] = PCREGISTERNDT(...) additionally returns the root mean
%   squared error of the Euclidean distance between the aligned point
%   clouds. A lower root mean squared error is indicative of better
%   registration.
%
%   [...] = PCREGISTERNDT(...,Name, Value) specifies additional
%   name-value pairs as described below:
%
%   'InitialTransform'  A rigid3d object to specify the initial rigid
%                       transformation. This is useful when a coarse
%                       estimate can be provided externally.
%
%                       Default: rigid3d object containing translation
%                                that moves the center of the moving point
%                                cloud to that of the fixed.
%
%   'OutlierRatio'      A scalar between 0 and 1 to specify the expected
%                       percentage of outliers with respect to a normal
%                       distribution. The NDT algorithm assumes a point is
%                       generated by a mixture of a normal distribution for
%                       inliers and a uniform distribution for outliers. A
%                       higher outlier ratio reduces the influence of
%                       outliers on the algorithm.
%
%                       Default: 0.55
%
%   'MaxIterations'     A positive integer to specify the maximum number
%                       of iterations before NDT stops.
%
%                       Default: 30
%
%   'Tolerance'         A 2-element vector, [Tdiff, Rdiff], to specify
%                       the tolerance of absolute difference in translation
%                       and rotation estimated in consecutive NDT
%                       iterations. Tdiff measures the Euclidean distance
%                       between two translation vectors, while Rdiff
%                       measures the angular difference in degrees. The
%                       algorithm stops when the difference between
%                       estimated rigid transformations in the most recent
%                       consecutive iterations falls below the specified
%                       tolerance value.
%
%                       Default: [0.01, 0.5]
%
%   'Verbose'           Set true to display progress information.
%
%                       Default: false
%
%   Class Support
%   -------------
%   moving and fixed must be pointCloud objects. tform is a rigid3d object.
%   movingReg is a pointCloud object. rmse is a single or double scalar.
%
%   Notes
%   -----
%   1. Prior to registration, PCREGISTERNDT voxelizes the fixed point cloud
%      using the specified gridStep. A smaller grid step will capture
%      distinct structure within the point cloud at the cost of being
%      dominated by local noise produced by the sensor. Use pcdownsample to
%      determine the affect of voxelization:
%           pcdownsample(fixed, 'gridAverage', gridStep)
%
%   2. To improve accuracy and efficiency of registration, consider
%      downsampling the moving point cloud using pcdownsample before using
%      PCREGISTERNDT.
%
%   Example: Align two point clouds using NDT algorithm
%   ---------------------------------------------------
%   ld = load('livingRoom.mat');
%   moving = ld.livingRoomData{1};
%   fixed  = ld.livingRoomData{2};
%
%   figure
%   pcshowpair(moving, fixed, 'VerticalAxis','Y','VerticalAxisDir','Down')
%
%   % Downsample the moving point cloud to improve efficiency and accuracy
%   movingDownsampled = pcdownsample(moving,'gridAverage', 0.1);
%
%   % Apply the rigid registration using NDT algorithm
%   gridStep = 0.5;
%   tform = pcregisterndt(movingDownsampled, fixed, gridStep);
%
%   % Visualize the alignment
%   movingReg = pctransform(moving, tform);
%
%   figure
%   pcshowpair(movingReg, fixed, 'VerticalAxis','Y','VerticalAxisDir','Down')
%
%
%   Example : Align two Lidar point clouds
%   --------------------------------------
%   % Construct a velodyneFileReader object
%   veloReader = velodyneFileReader('lidarData_ConstructionRoad.pcap', 'HDL32E');
%
%   % Read and visualize two Lidar point clouds
%   frameNumber = 1;
%   skipFrame   = 5;
%   fixed  = readFrame(veloReader, frameNumber);
%   moving = readFrame(veloReader, frameNumber + skipFrame);
%
%   % Segment and remove ground plane from fixed point cloud
%   groundPtsIdxFixed = segmentGroundFromLidarData(fixed);
%   fixedSeg = select(fixed, ~groundPtsIdxFixed, 'OutputSize', 'full');
%
%   % Segment and remove ground plane from moving point cloud
%   groundPtsIdxMoving = segmentGroundFromLidarData(moving);
%   movingSeg = select(moving, ~groundPtsIdxMoving, 'OutputSize', 'full');
%
%   % Downsample the moving point cloud to improve efficiency and accuracy
%   movingDownsampled = pcdownsample(movingSeg, 'gridAverage', 0.2);
%
%   % Register the moving point cloud w.r.t fixed point cloud
%   gridStep = 5;
%   tform = pcregisterndt(movingDownsampled, fixedSeg, gridStep);
%
%   % Transform moving point cloud using estimated rigid transformation
%   movingReg = pctransform(moving, tform);
%
%   % Visualize the alignment
%   figure
%   pcshowpair(movingReg, fixed)
%
%
% See also pointCloud, rigid3d, pctransform, pcdownsample, pcshow,
%          pcshowpair, pcregistericp, pcregistercpd, pcdenoise, pcmerge.

% Copyright 2017-2019 The MathWorks, Inc.
%
% References
% ----------
% [1] P. Biber, W. Strasser, "The normal distributions transform: A
%     new approach to laser scan matching," in Proceedings of IEEE/RSJ
%     International Conference on Intelligent Robots and Systems
%     (IROS), 2003, pp. 2743-2748
%
% [2] Magnusson, M. (2013). The Three-Dimensional Normal-Distributions
%     Transform - an Efficient Representation for Registration, Surface
%     Analysis, and Loop Detection. PhD thesis, Orebro University.

%#codegen

isSimMode = isempty(coder.target);

% Parse the inputs
[ptCloudA, ptCloudB, maxStepSize, outlierRatio, maxIterations, tolerance, ...
    initTform, verbose] = parseInputs(...
    moving, fixed, gridStep, varargin{:});
gridStep = double(gridStep);

% Convert to Euler angle format
x0 = vision.internal.eul.tform2pose(initTform);

% Voxelize the reference point cloud
minVoxelPoints = 6;         % Remove voxels that contain less than 6 points
eigenValueRatio = 100;      % Flat the covariance to avoid singularity
[mvals, iCov] = vision.internal.pc.voxelGridFilter(ptCloudB.Location, ...
    gridStep, minVoxelPoints, eigenValueRatio);

coder.internal.errorIf(isempty(mvals),'vision:pointcloud:notEnoughValidVoxels');

% Create kdtree for fast indexing
[kdtree, pLocationHandle] = constructKdtree(mvals);

% Initialize gaussian fitting parameters for estimation of likelihood of
% each point w.r.t to a distribution of a voxel that encloses the point. Eq
% 6.8, Martin 2013.
c1 = max(10*(1 - outlierRatio), eps);      % Gaussian-Distribution parameter c1
c2 = max(outlierRatio/gridStep^3, eps);    % Uniform distribution parameter c2
d3 = -log(c2);
d1 = -log(c1 + c2) - d3;
d2 = -2*log((-log(c1*exp(-0.5) + c2) - d3) / d1);

% Set up the NLP solver
args.ps = ptCloudA.Location;
args.mvals = mvals;
args.iCov = iCov;
args.tree = kdtree;
args.d1 = d1;
args.d2 = d2;
args.radius = gridStep;
args.SolutionEvaluationFcn = @solutionEvaluationNDT;

% solver = vision.internal.ndt.NLPSolverLineSearch(...
%     @visionNDTComputeScoreDerivatives, @solutionEvaluationNDT,...
%     @checkGradientInitializationNDT,args);

solver = NLPSolverLineSearch1(...
    @visionNDTComputeScoreDerivatives, @solutionEvaluationNDT,...
    @checkGradientInitializationNDT,args);

params = getSolverParams(solver);
params.MaxIterations = maxIterations;
params.MaxStepSize = maxStepSize;
params.ExtraSolutionEvalArgs = double(tolerance);

if isSimMode && verbose
    % Setup the message printer
    params.PrintFcn = @printMessage;
    params.Verbose = verbose;
end

solver = setSolverParams(solver, params);
% setSolverParams(solver, params);

% Search the best pose with line search algorithm
% x = solver.solve(x0(:));
[x, solutionInfo] = solve(solver, x0(:), args);

% Convert to rigid3d format
tform = vision.internal.eul.pose2tform(x.', class(moving.Location));


if nargout >= 2
    movingReg = pctransform(moving, tform);
end

if nargout >= 3
    % rmse is based on point-to-point correspondence
    ptCloudA = pctransform(ptCloudA, tform);    % ptCloudA is the moving point cloud
    [~, dists] = multiQueryKNNSearchImpl(ptCloudB, ptCloudA.Location, 1);
    rmse = sqrt(sum(dists(:))/numel(dists));
    rmse = cast(rmse,'like',moving.Location);
    
    % Added by Chet, August 26, 2021
    [~, dists_adj] = multiQueryKNNSearchImpl(ptCloudB, ptCloudA.Location, 1);
    
    % remove some huge correpondence
    k = 0;
    adj_dist = zeros(1,10);
    for i = 1:size(dists_adj, 2)
        if (dists_adj(i) > 0.25)
            continue;
        else
        k = k + 1;
        adj_dist(k) = dists_adj(i);
        end
    end
    dists_adj = adj_dist;
    rmse_adj = sqrt(sum(dists_adj(:))/numel(dists_adj));
    rmse_adj = cast(rmse_adj,'like',moving.Location);
end

solutionInfo.rmse = rmse;
solutionInfo.dists = dists;
solutionInfo.rmse_adj = rmse_adj;
solutionInfo.dists_adj = dists_adj;

deleteKdtree(kdtree, pLocationHandle,  class(mvals));
end

%--------------------------------------------------------------------------
function [ptCloudA, ptCloudB, maxStepSize, outlierRatio, maxIterations, tolerance, ...
    initTform, verbose] = parseInputs(...
    moving, fixed, gridStep, varargin)

coder.internal.prefer_const( varargin{:} );

validateattributes(moving, {'pointCloud'}, {'scalar'}, mfilename, 'moving');
validateattributes(fixed, {'pointCloud'}, {'scalar'}, mfilename, 'fixed');
validateattributes(gridStep, {'single', 'double'}, ...
    {'real','scalar', 'nonnan', 'nonsparse','positive'});

% A copy of the input with unorganized M-by-3 data
if isa(moving.Location, 'double')
    ptCloudA = removeInvalidPoints(moving);
else
    movingUnorg = removeInvalidPoints(moving);
    ptCloudA = pointCloud( double(movingUnorg.Location) );
end

if isa(fixed.Location, 'double')
    ptCloudB = removeInvalidPoints(fixed);
else
    fixedUnorg = removeInvalidPoints(fixed);
    ptCloudB = pointCloud(double(fixedUnorg.Location));
end

% At least three points are needed to determine a 3-D transformation
coder.internal.errorIf((ptCloudA.Count < 3 || ptCloudB.Count < 3), ...
    'vision:pointcloud:notEnoughPoints');

% Initial translation
t = mean(ptCloudB.Location) - mean(ptCloudA.Location);

% Set input parser
defaults = struct(...
    'StepSize',         0.1, ...
    'OutlierRatio',     0.55,...
    'MaxIterations',    30,...
    'Tolerance',        [0.01, 0.5], ...
    'InitialTransform', rigid3d(eye(3), t),...
    'Verbose',          false);

if isSimMode
    parser = inputParser;
    parser.CaseSensitive = false;
    
    parser.addParameter('StepSize', defaults.StepSize);
    parser.addParameter('OutlierRatio', defaults.OutlierRatio);
    parser.addParameter('MaxIterations', defaults.MaxIterations);
    parser.addParameter('Tolerance', defaults.Tolerance);
    parser.addParameter('InitialTransform', defaults.InitialTransform);
    parser.addParameter('Verbose', defaults.Verbose);
    
    parser.parse(varargin{:});
    
    maxStepSize      = parser.Results.StepSize;
    outlierRatio     = parser.Results.OutlierRatio;
    maxIterations    = parser.Results.MaxIterations;
    tolerance        = parser.Results.Tolerance;
    
    initialTransform = parser.Results.InitialTransform;
    
    verbose = parser.Results.Verbose;
else
    
    % Define parser mapping struct
    pvPairs = struct( ...
        'StepSize',         uint32(0), ...
        'OutlierRatio',     uint32(0), ...
        'MaxIterations',    uint32(0), ...
        'Tolerance',        uint32(0), ...
        'InitialTransform', uint32(0),...
        'Verbose',          uint32(0));
    
    % Specify parser options
    poptions = struct( ...
        'CaseSensitivity', false, ...
        'StructExpand',    true, ...
        'PartialMatching', true);
    
    % Parse PV pairs
    pstruct = coder.internal.parseParameterInputs(pvPairs, ...
        poptions, varargin{:});
    % Extract inputs
    maxStepSize       = coder.internal.getParameterValue(pstruct.StepSize, defaults.StepSize, varargin{:});
    outlierRatio      = coder.internal.getParameterValue(pstruct.OutlierRatio, defaults.OutlierRatio, varargin{:});
    maxIterations     = coder.internal.getParameterValue(pstruct.MaxIterations, defaults.MaxIterations, varargin{:});
    tolerance         = coder.internal.getParameterValue(pstruct.Tolerance, defaults.Tolerance, varargin{:});
    initialTransform  = coder.internal.getParameterValue(pstruct.InitialTransform, defaults.InitialTransform, varargin{:});
    verbose           = coder.internal.getParameterValue(pstruct.Verbose, defaults.Verbose, varargin{:});
end

funcName = mfilename;
validateattributes(maxStepSize, {'single', 'double'}, {'real','scalar','positive'},...
    funcName, 'StepSize');
validateattributes(outlierRatio,{'single', 'double'}, {'real','nonempty','scalar','>=',0,'<',1},...
    funcName, 'OutlierRatio');
validateattributes(maxIterations,{'single', 'double'}, {'scalar','integer','positive'},...
    funcName, 'MaxIterations');
validateattributes(tolerance,{'single', 'double'}, {'real','nonnegative','finite','numel', 2},...
    funcName, 'Tolerance');
validateattributes(initialTransform,{'affine3d','rigid3d'}, {'scalar'},funcName, 'InitialTransform');
validateattributes(verbose,{'logical'}, {'scalar','nonempty'}, funcName, 'Verbose');

if isa(initialTransform, 'affine3d')
  % Convert to rigid3d and extract transformation matrix
  initRigidTform = rigid3d(initialTransform.T);
  initTform = double(initRigidTform.T);
else
  initTform = double(initialTransform.T);
end

outlierRatio  = double(outlierRatio);
tolerance     = [double(tolerance(1)), double(tolerance(2))*pi/180];
maxIterations = double(maxIterations);
end

%--------------------------------------------------------------------------
function tf = solutionEvaluationNDT(x, xTrial, tolerance)
% Stop the NLP solver if pose change is below tolerance.

% Difference in translation
tdiff = x(1:3)-xTrial(1:3);

% Difference in rotation (radian)
rdiff = x(4:6)-xTrial(4:6);

tf = (tdiff'*tdiff < tolerance(1)^2) & (rdiff'*rdiff < tolerance(2)^2);
end

%--------------------------------------------------------------------------
function checkGradientInitializationNDT(~, gradient, ~)
% Check that gradient is valid at initialization

coder.internal.errorIf(all(gradient==0),'vision:pointcloud:ndtNoGradientAtInitialization');
end

%--------------------------------------------------------------------------
function printMessage(msg, arg)
% Verbose message printer for NLP solver

persistent printer;
if isempty(printer)
    printer = vision.internal.MessagePrinter.configure(true);
end

if msg == vision.internal.ndt.NLPSolverPrintFlags.IterationStart
    printer.linebreak;
    printer.print('--------------------------------------------\n');
    printer.printMessage('vision:pointcloud:ndtIteration',arg);
    
elseif msg == vision.internal.ndt.NLPSolverPrintFlags.CurrentFcn
    printer.printMessage('vision:pointcloud:ndtCurrentFcn',num2str(arg));
    
elseif msg == vision.internal.ndt.NLPSolverPrintFlags.CurrentVar
    printer.printMessage('vision:pointcloud:ndtCurrentVarTranslation',...
        num2str(arg.x(1)), num2str(arg.x(2)), num2str(arg.x(3)));
    printer.printMessage('vision:pointcloud:ndtCurrentVarRotation', ...
        num2str(rad2deg(arg.x(4))), num2str(rad2deg(arg.x(5))), num2str(rad2deg(arg.x(6))));
    
elseif msg == vision.internal.ndt.NLPSolverPrintFlags.IterationExit
    printer.linebreak;
    printer.print('--------------------------------------------\n');
    switch arg
        case vision.internal.ndt.NLPSolverExitFlags.ChangeInErrorBelowMinimum
            printer.printMessage('vision:pointcloud:nlpStopCondSmallAbsFunVal');
        case vision.internal.ndt.NLPSolverExitFlags.LocalMinimumFound
            printer.printMessage('vision:pointcloud:nlpStopCondSmallGrad');
        case vision.internal.ndt.NLPSolverExitFlags.StepSizeBelowMinimum
            printer.printMessage('vision:pointcloud:nlpStopCondSmallChangeOfX');
        case vision.internal.ndt.NLPSolverExitFlags.SolutionCheckFailed
            printer.printMessage('vision:pointcloud:ndtStopCondSolutionCheck');
        case vision.internal.ndt.NLPSolverExitFlags.MaximumIterationReached
            printer.printMessage('vision:pointcloud:nlpStopCondMaxIteration');
    end
end
end

%--------------------------------------------------------------------------
function flag = isSimMode()

flag = isempty(coder.target);
end

%--------------------------------------------------------------------------
function [kdtree, pLocationHandle] = constructKdtree(mvals)
% Create kdtree for fast indexing

options = struct('numTrees', 1, 'bucketSize', 1, 'seed', 0);
if isSimMode
    kdtree = vision.internal.Kdtree();
    kdtree.index(mvals, options);
    pLocationHandle = [];
elseif pointclouds.internal.codegen.isTargetMATLABHost
    kdtree = vision.internal.buildable.kdtreeBuildable.kdtreeConstruct(class(mvals));
    if ismatrix(mvals)
        numPts = size(mvals,1);
        numDims = size(mvals,2);
    else
        numPts = size(mvals,1) * size(mvals,2);
        numDims = size(mvals,3);
    end
    pLocationHandle = vision.internal.buildable.kdtreeBuildable.kdtreeGetLocationPointer(mvals, class(mvals));
    vision.internal.buildable.kdtreeBuildable.kdtreeIndex(kdtree, class(mvals), pLocationHandle, numPts, numDims, options);
else
    kdtree = vision.internal.codegen.Kdtree(class(mvals));
    if ~isempty(kdtree) && ~kdtree.IsIndexed
        kdtree.index(mvals);
    end
     pLocationHandle = [];
end

end


function deleteKdtree(kdtree, pLocationHandle, pointCloudDataType)
if ~isSimMode && pointclouds.internal.codegen.isTargetMATLABHost
    
    vision.internal.buildable.kdtreeBuildable.kdtreeDeleteLocationPointer(pLocationHandle,...
        pointCloudDataType);
    
    vision.internal.buildable.kdtreeBuildable.kdtreeDelete(kdtree, pointCloudDataType);
    
end
end

%==================================================================
% Main function to run line search algorithm (searching & estimating step length). 
% Modified & Added by: Surachet Srinara (Chet), PhD candidate
% Date: April 21, 2021
%==================================================================
function [xSol, solutionInfo] = solve(thisSolver, x0, args)            
x = x0;
            
% Initialize score, gradient and hessian (or hessian approximate)
[score, grad, Hessian] = thisSolver.CostFcn(x, args);
            
if ~isempty(thisSolver.CheckInitializationFcn)
    thisSolver.CheckInitializationFcn(score, grad, Hessian);
end
            
% Disable the warnings about conditioning for singular and
% nearly singular matrices
if isSimMode
    warningstate1 = warning('off','MATLAB:nearlySingularMatrix');
    warningstate2 = warning('off','MATLAB:singularMatrix');
    warningstate3 = warning('off','MATLAB:rankDeficientMatrix');
end
            
% Main iteration loop
maxScore = score;
bestX = x;
bestIter = 0;
exitFlag = vision.internal.ndt.NLPSolverExitFlags.Success;
bestGrad = grad;
bestHessian = Hessian;
            
for iter = 1:thisSolver.MaxIterations
    if isSimMode && thisSolver.Verbose
        thisSolver.PrintFcn(vision.internal.ndt.NLPSolverPrintFlags.IterationStart, iter);
    end
    % Solve for H*dx = -g
    dx = Hessian \ (-grad);     % search direction
                
    % Normalized descent direction
    xnorm = sqrt(dx' * dx);
    dx = dx / xnorm;
                
    % Set the value of phi and phi' in equation-1.3[More, Thuente 1994]
    phi_0 = -score;
    dphi_0 = -grad'*dx;
     
    % Estimate a step length using line search
    [xTrial, scoreTrial, gradTrial, HessianTrial] = lineSearch(thisSolver, x, dx, ...
                    phi_0, dphi_0, thisSolver.GradientTolerance, thisSolver.MaxStepSize, xnorm);
                
    % EXIT condition: minimum change in function value
    if changeInScoreBelowMinimum(thisSolver, score, scoreTrial)
        exitFlag = vision.internal.ndt.NLPSolverExitFlags.ChangeInErrorBelowMinimum;
        % EXIT condition: local minimum found
    elseif atLocalMinimum(thisSolver, gradTrial)
        exitFlag = vision.internal.ndt.NLPSolverExitFlags.LocalMinimumFound;
        % EXIT condition: minimum step size
    elseif stepSizeBelowMinimum(thisSolver, x, xTrial)
        exitFlag = vision.internal.ndt.NLPSolverExitFlags.StepSizeBelowMinimum;
        % EXIT condition: check solution by user function
    elseif ~isempty(thisSolver.SolutionEvaluationFcn)
        if thisSolver.SolutionEvaluationFcn(x, xTrial, thisSolver.ExtraSolutionEvalArgs)
            exitFlag = vision.internal.ndt.NLPSolverExitFlags.SolutionCheckFailed;
            % EXIT condition: stop the NLP solver if pose change is below tolerance.
        end
    end
    if isSimMode &&  thisSolver.Verbose
        % Display results at each iteration
        thisSolver.PrintFcn(vision.internal.ndt.NLPSolverPrintFlags.CurrentFcn, scoreTrial);
        args.x = xTrial;
        args.grad = gradTrial;
        thisSolver.PrintFcn(vision.internal.ndt.NLPSolverPrintFlags.CurrentVar, args);
    end
    if int32(exitFlag)
        if maxScore < scoreTrial
            bestX = xTrial;
            maxScore = scoreTrial;
            bestGrad = gradTrial;
            bestHessian = HessianTrial;
        end
        if maxScore < score
            bestX = x;
            maxScore = score;
            bestGrad = grad;
            bestHessian = Hessian;
        end
        break;
    else
        x = xTrial;
        score = scoreTrial;
        grad = gradTrial;
        Hessian = HessianTrial;
        % Record the best solution so far
        if maxScore < score
            bestX = x;
            maxScore = score;
            
            bestGrad = grad;
            bestHessian = Hessian;
        end
    end
end
if isSimMode
% Restore the warning states to their original settings
    warning(warningstate1)
    warning(warningstate2)
    warning(warningstate3)
end
% EXIT condition: maximum iteration reached
if (~int32(exitFlag))
    exitFlag = vision.internal.ndt.NLPSolverExitFlags.MaximumIterationReached;
end

% Final output:
xSol = bestX;
solutionInfo.Iterations = iter;
solutionInfo.Objective  = maxScore;
solutionInfo.ExitFlag   = exitFlag;
solutionInfo.grad       = bestGrad;
solutionInfo.Hessian    = bestHessian;
solutionInfo.dx         = dx;
solutionInfo.x          = x;
solutionInfo.xTrial     = xTrial;

if isSimMode && thisSolver.Verbose
    thisSolver.PrintFcn(vision.internal.ndt.NLPSolverPrintFlags.IterationExit, exitFlag);
end
end

%--------------------------------------------------------------------------
% Estimate a step length using 'line search'
function [x_t, score, grad, Hessian] = lineSearch(thisSolver, x0, dx, ...
                                                  phi_0, dphi_0, a_min, a_max, a_init)
% lineSearch compute the line search algorithm with guaranteed
% sufficient decrease.
%
% [1] More and Thuente, Line Search Algorithm with Guaranteed
% Sufficient Decrease, ACM Trans. on Mathematical Software, Vol 20,
% No. 3, 1994
if ~isSimMode
    thisSolver.CostFcn = @vision.internal.buildable.ndtComputeScoreDerivativesBuildable....
                    .ndtComputeScoreDerivatives;
end
            
% Check the decent direction.
if dphi_0 >= 0
   % Not a decent direction.
   if dphi_0 == 0
        x_t = x0 + dx * thisSolver.MaxStepSize;
        [score, grad, Hessian] = thisSolver.CostFcn(x_t, thisSolver.ExtraArgs);
        return
   else
        % Reverse step direction and calculate optimal step.
        dphi_0 = -dphi_0;
        dx = -dx;
   end
end
            
% Sufficient decreace constant, Equation 1.1 [More, Thuete 1994]
mu = 0.0001;
% Curvature condition constant, Equation 1.2 [More, Thuete 1994]
nu = 0.9;
% Initial endpoints of Interval I
a_l = 0;
a_u = 0;
            
f_l = 0;
g_l = dphi_0 - dphi_0 * mu;
            
f_u = 0;
g_u = g_l;
            
% Check used to allow More-Thuente step length calculation to
% be skipped
interval_converged = (a_max -a_min) < 0.0001;
open_interval = true;
            
a_t = a_init;
a_t = min(a_t, a_max);
a_t = max(a_t, a_min);
            
x_t = x0 + dx * a_t;
            
% Updates score, gradient and hessian.
[score, grad, Hessian] = thisSolver.CostFcn(x_t, thisSolver.ExtraArgs);
            
% Calculate phi(alpha_t) and phi'(alpha_t)
phi_t = -score;
dphi_t = -grad' * dx;
            
% Calculate psi(alpha_t) and psi'(alpha_t)
psi_t =  phi_t - phi_0 - a_t * dphi_0 * mu;
dpsi_t = dphi_t - dphi_0 * mu;
            
% The search algorithm for T(mu)
maxIterations = 10;
iter = 0;
            
% Iterate until max number of iterations, interval convergence
% or a value satisfies the sufficient decrease, Equation 1.1,
% and curvature condition, Equation 1.2 [More, Thuente 1994]
while (~interval_converged && iter < maxIterations && ...
    ~(psi_t <= 0 && dphi_t <= -nu * dphi_0))
    % Use auxilary function if interval I is not closed
    if open_interval
        a_t = vision.internal.ndt.selectTrialValue(a_l, f_l, g_l, ...
        a_u, f_u, g_u, a_t, psi_t, dpsi_t);
    else
        a_t = vision.internal.ndt.selectTrialValue(a_l, f_l, g_l, ...
        a_u, f_u, g_u, a_t, phi_t, dphi_t);
    end
                
    a_t = min(a_t, a_max);
    a_t = max(a_t, a_min);
                
    x_t = x0 + dx * a_t;
                
    [score, grad] = thisSolver.CostFcn(x_t, thisSolver.ExtraArgs);
                
    % Calculate phi(alpha_t) and phi'(alpha_t)
    phi_t = -score;
    dphi_t = -grad' * dx;
                
    % Calculate psi(alpha_t) and psi'(alpha_t)
    psi_t = phi_t - phi_0 - a_t * dphi_0 * mu;
    dpsi_t = dphi_t - dphi_0 * mu;
                
    % Check if I is now a closed interval
    if open_interval && (psi_t <= 0 && dpsi_t >= 0)
        open_interval = false;
                    
        % Converts f_l and g_l from psi to phi
        f_l = f_l + phi_0 - mu * dphi_0 * a_l;
        g_l = g_l + mu * dphi_0;
                    
        % Converts f_u and g_u from psi to phi
        f_u = f_u + phi_0 - mu * dphi_0 * a_u;
        g_u = g_u + mu * dphi_0;
    end
                
    if open_interval
        % Update interval end points using Updating Algorithm
        % [More, Thuente 1994]
        [a_l, f_l, g_l, a_u, f_u, g_u, interval_converged] = ...
                        vision.internal.ndt.updateInterval(a_l, f_l, g_l, a_u, f_u, g_u, a_t, psi_t, dpsi_t);
    else
        % Update interval end points using Modified Updating
        % Algorithm [More, Thuente 1994]
        [a_l, f_l, g_l, a_u, f_u, g_u, interval_converged] = ...
                        vision.internal.ndt.updateInterval(a_l, f_l, g_l, a_u, f_u, g_u, a_t, phi_t, dphi_t);
    end
                
    iter = iter + 1;
end
            
% If inner loop was run then hessian needs to be calculated.
% Hessian is unnecessary for step length determination but
% gradients are required so derivative and transform data is
% stored for the next iteration.
if (iter)
    if isSimMode
        [score, grad, Hessian] = thisSolver.CostFcn(x_t, thisSolver.ExtraArgs);
    else
        [score, grad, Hessian] = vision.internal.buildable.ndtComputeScoreDerivativesBuildable....
                        .ndtComputeScoreDerivatives(x_t, thisSolver.ExtraArgs);
    end
end
end

%--------------------------------------------------------------------------
function flag = atLocalMinimum(thisSolver, grad)
flag = max(abs(grad)) < thisSolver.GradientTolerance;
end
 
%--------------------------------------------------------------------------
function flag = changeInScoreBelowMinimum(thisSolver, score, scoreTrial)
flag = abs(score - scoreTrial) < thisSolver.FunctionTolerance;
end
 
%--------------------------------------------------------------------------
function flag = stepSizeBelowMinimum(thisSolver, x, xTrial)
d = x - xTrial;
flag = d' * d < thisSolver.StepTolerance^2;
end

%--------------------------------------------------------------------------
function params = getSolverParams(thisSolver)
    params.MaxIterations            = thisSolver.MaxIterations;
    params.GradientTolerance        = thisSolver.GradientTolerance;
    params.MaxStepSize              = thisSolver.MaxStepSize;
    params.FunctionTolerance        = thisSolver.FunctionTolerance;
    params.SolutionEvaluationFcn    = thisSolver.SolutionEvaluationFcn;
    params.ExtraSolutionEvalArgs    = thisSolver.ExtraSolutionEvalArgs;
    params.StepTolerance            = thisSolver.StepTolerance;
    params.PrintFcn                 = thisSolver.PrintFcn;
    params.Verbose                  = thisSolver.Verbose;
    params.CheckInitializationFcn   = thisSolver.CheckInitializationFcn;
end

%--------------------------------------------------------------------------
function thisSolver = setSolverParams(thisSolver, params)
% function setSolverParams(thisSolver, params)
    thisSolver.MaxIterations          = params.MaxIterations;
    thisSolver.GradientTolerance      = params.GradientTolerance;
    thisSolver.StepTolerance          = params.StepTolerance;
    thisSolver.FunctionTolerance      = params.FunctionTolerance;
    thisSolver.MaxStepSize            = params.MaxStepSize;
    thisSolver.SolutionEvaluationFcn  = params.SolutionEvaluationFcn;
    thisSolver.ExtraSolutionEvalArgs  = params.ExtraSolutionEvalArgs;
    thisSolver.PrintFcn               = params.PrintFcn;
    thisSolver.Verbose                = params.Verbose;
    thisSolver.CheckInitializationFcn = params.CheckInitializationFcn;
end

%--------------------------------------------------------------------------
function currNLPSolver = NLPSolverLineSearch1(costFcn, evaluateFcn, checkGradFcn, varargin)
%NLPSolverLineSearch Constructor
currNLPSolver.MaxIterations = 100;
currNLPSolver.MaxStepSize = 1000;
currNLPSolver.GradientTolerance = 1e-6;
currNLPSolver.FunctionTolerance = 1e-6;
currNLPSolver.StepTolerance = 1e-6;
            
validateattributes(costFcn,{'function_handle'},{'scalar'});
if isSimMode
    currNLPSolver.CostFcn = costFcn;
else
    % Codegen supports NDT's cost function only , not any other cost
    % function given by function handle
    currNLPSolver.CostFcn = @vision.internal.buildable.ndtComputeScoreDerivativesBuildable....
                    .ndtComputeScoreDerivatives;
end
if ~isempty(varargin)
    currNLPSolver.ExtraArgs = varargin{1};
end
validateattributes(evaluateFcn,{'function_handle'},{'scalar'});
currNLPSolver.SolutionEvaluationFcn = evaluateFcn;
currNLPSolver.ExtraSolutionEvalArgs  = [0,0];
validateattributes(checkGradFcn,{'function_handle'},{'scalar'});
currNLPSolver.CheckInitializationFcn = checkGradFcn;
currNLPSolver.PrintFcn = @printMessage;
currNLPSolver.Verbose = false;
end

%--------------------------------------------------------------------------